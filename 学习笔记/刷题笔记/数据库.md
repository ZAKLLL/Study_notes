

# 数据库

+ 设计范式：

  + 1 、第一范式（1NF）

    + 指数据库表的每一列(即每个属性)都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。简而言之，第一范式就是无重复的列。

  + 2、 第二范式（2NF）

    + 第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。

    + 第二范式（2NF）要求实体的属性完全依赖于主关键字。

    + 所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。

      简而言之，第二范式就是非主属性依赖于主关键字。

  + 3 、第三范式（3NF）

    + 在满足第二范式的基础上，切不存在传递函数依赖，那么就是第三范式。
  
+ 简而言之，第三范式就是属性不依赖于其它非主属性。
  
+ Join关键字：
  
  + ![1567335994073](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1567335994073.png)
  + 数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。 在使用left jion时，on和where条件的区别如下：
    + 1. on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。
      2. where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。
  
+ Mysql联合索引最左匹配原则:

  + ```sql
    CREATE TABLE `user` (
      `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键Id',
      `name` varchar(255) DEFAULT NULL COMMENT '名称',
      `age` int(11) DEFAULT NULL COMMENT '年龄',
      `address` varchar(255) DEFAULT NULL COMMENT '地址',
      `created_time` datetime DEFAULT NULL COMMENT '创建时间',
      `updated_time` datetime DEFAULT NULL COMMENT '更新时间',
      PRIMARY KEY (`id`),
      KEY `idx_com1` (`name`,`age`,`address`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表';
    ```

  + ```sql
    该查询语句没有使用到索引idx_com1
    select  *  from user where age = 25 and address='北京大兴区';
    原因：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候
    b+数是按照从左到右的顺序来建立搜索树的，
    比如当(张三,20,F)这样的数据来检索的时候，
    b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；
    但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点
    ```

+ **truncate**和**delete**的相同点与不同点：

  + **相同点**：
  
    + 效果上，delete from tableA，与truncate table tableA的作用是一样的（如果delete后面不添加where条件过滤），而且与drop table tableA，接着create table tableA的效果也是一样的。
  + **不同点** ：
    + **1、语言上**
      + delete是DML，truncate是DDL，执行truncate需要drop权限。
    + **2、效率上**
      + delete是一行一行的删除，所以执行速度不快。由于truncate是DDL，是通过删除表然后重建表实现的，执行速度很快。
    + **3、事务上**
      + delete过程如果出现错误，事务是可以回滚的，而truncate无法回滚。
    + **4、效果上**
        + delete可以删除符合条件的数据行，而truncate只能删除整体
  
        + delete可以返回被删除的记录数，而truncate只返回0，没有任何意义
  
        + 在存储引擎为InnoDB的数据库服务器中，如果一个表的主键作为了另一个表的外键，那么truncate无法删除这个表中的数据，无论这个外键是否存在，这是由于drop表限制的。而delete可以，只要这个表的主键在另一个表的外键中不存在即可。
  
        + truncate删除一个表的数据后，这个表的auto_increment列重新设置为初始大小，而delete则使用删除之前的顺序。索引同理。
  
        + truncate 之后，如果该表有自增主键，则该主键被置为0，delete不会重置自增主键。
  
## SQL四类语言：

   + **DDL** ：(Data Definition Language 数据定义语言）用于操作对象及对象本身，这种对象包括数据库,表对象，及视图对象：
        + create:创建数据库和数据库的一些对象
        + drop:删除数据表、索引、触发程序、条件约束以及数据表的权限等
        + alter:修改数据表定义及数据属性
   + **DML**: （Data Manipulation Language 数据操控语言) 用于操作数据库对象对象中包含的数据
     - insert:向数据库插入一条数据
      - delete:删除表中的一条或多条记录
      - update:用于修改表中的数据   
   + **DQL**:(Data Query Language 数据查询语言 )用于查询数据
     - select:用于查询表中的数据
   + **DCL** : （Data Control Language 数据控制语句） 用于操作数据库对象的权限
       + greate:分配权限给用户
       + revoke:废除数据库中某用户的权限
+ **ACID**:
  + **原子性**(Atomicity)：事务是一组不可分割的操作单元，这组单元要么同时成功要么同时失败（由DBMS的事务管理子系统来实现）；
  + **一致性**(Consistency)：事务前后的数据完整性要保持一致（由DBMS的完整性子系统执行测试任务）；
  + **隔离性**(Isolation):多个用户的事务之间不要相互影响，要相互隔离（由DBMS的并发控制子系统实现）；
  + **持久性**(durability):一个事务一旦提交，那么它对数据库产生的影响就是永久的不可逆的，如果后面再回滚或者出异常，都不会影响已提交的事务（由DBMS的恢复管理子系统实现的）

​        

+ 隔离级别：

  + Read uncommitted :（读未提交数据）

  + Read committed: （读已提交数据）

  + Repeatable read:（可重复读）

  + Serializable:（串行化）

    ![1567581867263](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1567581867263.png)
    
    **脏读** ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
    
    **不可重复读** ：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果 只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。
    
     **幻读** : 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。 如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。
    
    **不可重复读和幻读的区别：** 简单来说，不可重复读是由于数据修改引起的，幻读是由数据插入或者删除引起的。

+ 传播行为：
  
  + ![1567581983613](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1567581983613.png)
  
+ **为什么要使用索引？**

  1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
  2. 可以大大加快 数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。 
  3. 帮助服务器避免排序和临时表
  4. 将**随机IO变为顺序IO** (将无序的数据变成有序的数据)
  5. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

+ **Mysql索引主要使用的哪两种数据结构？**

  - 哈希索引：对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为**单条记录查询**的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。
  - BTree索引：Mysql的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。

+ **什么是覆盖索引?**

  + 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称
  之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

+ **主键**与**索引**

  1. 主键为一种约束，唯一索引为一种索引，本质上就不同；

  2. 主键创建后一定包含唯一性索引，而唯一索引不一定就是主键； 

  3. 主键不允许空值，唯一索引可以为空；

  4. 主键可以被其他表引用，而唯一索引不可以；

  5. 一个表最多只能创建一个主键，而可以创建多个唯一索引；

  6. 主键和索引都是键，主键是逻辑键，索引为物理键，即主键不实际存在。  

  7. 索引对删除的影响：如果要删除的字段与建立索引的字段相同，删除效率会提高，如果不同，效率降低。

  
  
  ​		
  
+ 索引失效的操作：

  + 条件中有or，即使有条件带索引也不会使用；**要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引**
  + 对于多列索引，如果不是使用的第一部分，则不会使用索引;(最左匹配原则)
  + like查询是以%开头的，不会用到索引
  + 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引;
  + 如果mysql估计使用全表扫描要比使用索引快,则不使用索引;
  + 条件中包含&lt;  &gt;
  + **将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描**

+ 数据库表结构修改
  
  + 删除列 ：ALTER TABLE table_name DROP clume_name
  + 添加列:   ALTER TABLE table_name ADD  column_name  dataType
  + 删除表： DROP TABLE table_name
  
  

+ 数据库模式：

  + 外模式：

    + 外模式又称子模式或用户模式，对应于用户级。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的[逻辑表示](https://baike.baidu.com/item/逻辑表示)。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、定义对应于用户的[数据记录](https://baike.baidu.com/item/数据记录)(外模式)，也可以利用[数据操纵语言](https://baike.baidu.com/item/数据操纵语言)(Data Manipulation Language，DML)对这些数据记录进行操作。外模式反映了数据库系统的用户观。

  + 模式(概念模式):

    + 概念模式又称模式或逻辑模式，对应于概念级。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据模式描述语言(Data Description Language，DDL)来描述、定义的。概念模式反映了[数据库系统](https://baike.baidu.com/item/数据库系统)的整体观。

  + 内模式:

    + 内模式又称存储模式，对应于物理级。它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义的。内模式反映了数据库系统的存储观。

      在一个数据库系统中，只有唯一的数据库， 因而作为定义 、描述数据库存储结构的内模式和定义、描述数据库逻辑结构的模式，也是唯一的，但建立在数据库系统之上的应用则是非常广泛、多样的，所以对应的外模式不是唯一的，也不可能是唯一的。

  + ![1569069240059](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1569069240059.png)

+ **Innodb**和**MyISAM**:

  + InnoDB 支持事务，MyISAM 不支持事务。
  +  InnoDB 支持外键，而 MyISAM 不支持。
  + InnoDB 是聚集索引，MyISAM 是非聚集索引。
    + 聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
  + InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
  + InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。

+ 锁:

  + 共享锁(s)：读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能对A再加S锁，而不能加X锁，直到T释放A上的锁；
  + 排他锁(x)：又称写锁，若事务T对数据对象A加上X锁，则事务T可以读A也可以修改，其他事务不能再对A加任何锁，直到T释放A上的锁。



+ 数据库优化方案：
  + 数据分区
  + 索引
  + 缓存机制
  + 加大虚存
  + **分批处理**
  + 使用临时表和中间表
  + 优化查询语句
  + 使用视图
  + 使用存储过程
  + 用排序来取代非顺序存储

+ 在Mysql中不能对一张表同时进行删除查询操作，需要建立中间表：

  + 编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。

    ```sql
delete from Person 
    	where Id not in 
    		(select Id From
             	(select min(Id) as Id from Person group by Email) 
             as t) ;
    #需要临时表t才能进行删除+查询的操作
    ```
    
    





## Sql关键词：

- Limit&&offset:

  - ```sql
    语句1：select * from student limit 9,4
    语句2：slect * from student limit 4 offset 9
    // 语句1和2均返回表student的第10、11、12、13行  
    //语句2中的4表示返回4行，9表示从表的第十行开始
    ```

    

- IFNULL:

  - ```sql
    编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。
    
    +----+--------+
    | Id | Salary |
    +----+--------+
    | 1  | 100    |
    | 2  | 200    |
    | 3  | 300    |
    +----+--------+
    select IFNULL(
        (select Salary 
        from Employee 
        group by Salary desc limit 1,1),null) as SecondHighestSalary ;
    
    
    ```

- DATEDIFF(判断时间差)：

  - ```sql
    给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。
    
    +---------+------------------+------------------+
    | Id(INT) | RecordDate(DATE) | Temperature(INT) |
    +---------+------------------+------------------+
    |       1 |       2015-01-01 |               10 |
    |       2 |       2015-01-02 |               25 |
    |       3 |       2015-01-03 |               20 |
    |       4 |       2015-01-04 |               30 |
    +---------+------------------+------------------+
    例如，根据上述给定的 Weather 表格，返回如下 Id:
    +----+
    | Id |
    +----+
    |  2 |
    |  4 |
    +----+
    select w2.Id from Weather w1,Weather w2 where DATEDIFF(w2.RecordDate,w1.RecordDate)=1 and  w2.Temperature>w1.Temperature;
    ```

    
    
