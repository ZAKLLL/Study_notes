+ 一趟结束后能够确定一个元素的最终位置的排序方法有： 简单选择排序、快速排序、冒泡排序、堆排序

+ **稳定性定义：**排序前后两个相等的数相对位置不变，则算法稳定。

+ 常用排序时间复杂度：

  + 插入排序：最佳O（N）

  + 快速排序：最佳O（NlogN）

  + 堆    排序：最佳O（NlogN）

  + 归并排序：最佳O（NlogN）

  + 前面的为非线性比较类排序，后三个为线性时间非比较排序。
  
    ![1567996555878](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1567996555878.png)



+ 数据结构                   search                                                      insert                        delete
  数组               O(n)，有序数组折半查找是O(lgn)                        O(n)                          O(n)
  双向链表                   O(n)                                                           O(1)                          O(1)
  排序二叉树              O(lgn)                                                        O(lgn)                         O(lgn)
  哈希表（n与槽数m成正比）O(1)                                              O(1)                             O(1)

+ 快速排序算法:

  + ```java
    public static int[] qsort(int arr[],int start,int end) {        
        int pivot = arr[start];        
        int i = start;        
        int j = end;        
        while (i<j) {            
            while ((i<j)&&(arr[j]>pivot)) {                
                j--;            
            }            
            while ((i<j)&&(arr[i]<pivot)) {                
                i++;            
            }            
            if ((arr[i]==arr[j])&&(i<j)) {                
                i++;            
            } else {                
                int temp = arr[i];                
                arr[i] = arr[j];                
                arr[j] = temp;            
            }        
        }        
        if (i-1>start) arr=qsort(arr,start,i-1);        
        if (j+1<end) arr=qsort(arr,j+1,end);        
        return (arr);    
    }    
    ```

+ 大顶堆：(根节点的关键字既大于等于左子树的关键字值，同时也大于等于右子树的关键字值)

+ 小顶堆：(根结点的键值是所有堆结点键值中最小者)





### 典例

+ 4的幂：

  + ```java
    这个题和“2的幂”“3的幂”一样，有不用循环和递归就能直接判断的方法，同样十分巧妙，属于二进制/位运算的应用。
    4的幂的数，都是这样的数：100、10000、1000000……（4、16、64）
    观察规律，可以发现 4的幂 需要满足以下条件：
    最高位是 1，其余都为 0；
    最高位的 1 应该在奇数位上，比如：100 的 1 在 第三位上；
    那么对应的判断方法为：
    用 num & (num-1) 可以判断条件1，比如：100(4) & 011(3) == 0，结果为 0 说明符合条件1；
    是否在奇数位可以用 0xaaaaaaaa 判断，16 进制的 a 是 1010，比如：0100(4) & 1010(a) == 0，结果为 0 说明最高位 1 在奇数位上；
    
     public boolean isPowerOfFour(int n) {
            return n > 0 && (n & (n - 1)) == 0 && ((n & 0x55555555) == n);
            
            //        if (n<0) return false; 
    	    //        if ((n&(n-1))!=0) return false; 判断是否位2的幂次方
    		//        return (n & 0x55555555) == n;   判断1是否在奇数位上
            
        }
    ```

    