+ 一趟结束后能够确定一个元素的最终位置的排序方法有： 简单选择排序、快速排序、冒泡排序、堆排序

+ **稳定性定义：**排序前后两个相等的数相对位置不变，则算法稳定。

+ 常用排序时间复杂度：

  + 插入排序：最佳O（N）

  + 快速排序：最佳O（NlogN）

  + 堆    排序：最佳O（NlogN）

  + 归并排序：最佳O（NlogN）

  + 前面的为非线性比较类排序，后三个为线性时间非比较排序。
  
    ![1567996555878](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1567996555878.png)



+ 数据结构                   search                                                      insert                        delete
  数组               O(n)，有序数组折半查找是O(lgn)                        O(n)                          O(n)
  双向链表                   O(n)                                                           O(1)                          O(1)
  排序二叉树              O(lgn)                                                        O(lgn)                         O(lgn)
  哈希表（n与槽数m成正比）O(1)                                              O(1)                             O(1)

+ 快速排序算法:

  + ```java
    public static int[] qsort(int arr[],int start,int end) {        
        int pivot = arr[start];        
        int i = start;        
        int j = end;        
        while (i<j) {            
            while ((i<j)&&(arr[j]>pivot)) {                
                j--;            
            }            
            while ((i<j)&&(arr[i]<pivot)) {                
                i++;            
            }            
            if ((arr[i]==arr[j])&&(i<j)) {                
                i++;            
            } else {                
                int temp = arr[i];                
                arr[i] = arr[j];                
                arr[j] = temp;            
            }        
        }        
        if (i-1>start) arr=qsort(arr,start,i-1);        
        if (j+1<end) arr=qsort(arr,j+1,end);        
        return arr;    
    }    
    ```

+ 大顶堆：(根节点的关键字既大于等于左子树的关键字值，同时也大于等于右子树的关键字值)

+ 小顶堆：(根结点的键值是所有堆结点键值中最小者)





### 典例

+ 4的幂：

  + ```java
    这个题和“2的幂”“3的幂”一样，有不用循环和递归就能直接判断的方法，同样十分巧妙，属于二进制/位运算的应用。
    4的幂的数，都是这样的数：100、10000、1000000……（4、16、64）
    观察规律，可以发现 4的幂 需要满足以下条件：
    最高位是 1，其余都为 0；
    最高位的 1 应该在奇数位上，比如：100 的 1 在 第三位上；
    那么对应的判断方法为：
    用 num & (num-1) 可以判断条件1，比如：100(4) & 011(3) == 0，结果为 0 说明符合条件1；
    是否在奇数位可以用 0xaaaaaaaa 判断，16 进制的 a 是 1010，比如：0100(4) & 1010(a) == 0，结果为 0 说明最高位 1 在奇数位上；
    
     public boolean isPowerOfFour(int n) {
            return n > 0 && (n & (n - 1)) == 0 && ((n & 0x55555555) == n);
            
            //        if (n<0) return false; 
    	    //        if ((n&(n-1))!=0) return false; 判断是否位2的幂次方
    		//        return (n & 0x55555555) == n;   判断1是否在奇数位上
            
        }
    ```

  
  ![1570120052428](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1570120052428.png)

+ 二叉树的公共祖先：

  + 最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

    例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

    ![1570191374301](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1570191374301.png)


  + ```java
    class Solution {
        /*
        算法思想,当递归到的节点为p1或p2时候,则将该节点向上传递,
        使其父节点变成其本身,如果一个节点下方没有p1/p2,则向上传递null,使父节点为null,
        当左右节点分别是p1,p2时则说明该节点是目标节点，向上传递,
        该目标节点对应的兄弟节点经过递归后一定为null(因为兄弟节点的子节点中不存在p1/p2只能向上传递null),	最终目标顶点传递至根节点。
        */
        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p1, TreeNode p2) {
          if (root == null || root == p1 || root == p2) return root;
            TreeNode left = lowestCommonAncestor(root.left, p1, p2);
            TreeNode right = lowestCommonAncestor(root.right, p1, p2);
            if (left == null && right == null) return null;
            if (left == null || right == null) return left == null ? right : left;
            return root;
        }
    }
    ```

  + 括号生成

    + 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

      例如，给出 n = 3，生成结果为：

      [  "((()))",
        "(()())",
        "(())()",
        "()(())",
        "()()()"]

    + ```java
       public List<String> generateParenthesis(int n) {
              List<String> res = new ArrayList<>();
              generate(res, "", 0, 0, n);
              return res;
          }
        
          //count1统计“(”的个数，count2统计“)”的个数
          public void generate(List<String> res, String ans, int count1, int count2, int n) {
              if (count1 > n || count2 > n) return;
              if (count1 == n && count2 == n) res.add(ans);
              /*核心点: count1>=count2 ,
              从左往右添加,只有满足左边括号数量>=右边括号时候,
              才能够满足题意,否则会出现括号不匹配的情况
              */
              if (count1 >= count2) {
                  generate(res, ans + "(", count1 + 1, count2, n);
                  generate(res, ans + ")", count1, count2 + 1, n);
              }
          }
      ```

       
    
    

+ BFS:

  + ![图](E:\Python_demo\图.jpg)

  ```python
  # 广度遍历
  graph = {
      "A": ["B", "C"],
      "B": ["A", "C", "D"],
      "C": ["A", "B", "D", "E"],
      "D": ["B", "C", "E", "F"],
      "E": ["C", "D"],
      "F": ["D"]
  }
  
  
  def BFS(graph, s):
      queue = []  # 使用动态数组作队列
      queue.append(s)
      seen = set()
      while (len(queue) > 0):
          vertex = queue.pop(0) # 每次取队列中的第一个再进行添加
          seen.add(s)
          nodes = graph[vertex]
          for w in nodes:
              if w not in seen:
                  queue.append(w)
                  seen.add(w)
          print(vertex)
  
  
  BFS(graph, "A")
  
  ```

+ DFS

  + ```python
    # 深度遍历
    graph = {
        "A": ["B", "C"],
        "B": ["A", "C", "D"],
        "C": ["A", "B", "D", "E"],
        "D": ["B", "C", "E", "F"],
        "E": ["C", "D"],
        "F": ["D"]
    }
    
    
    def DFS(graph, s):
        queue = []  # 使用动态数组作栈
        queue.append(s)
        seen = set()
        seen.add(s)
        parent = {s: None} # <子节点:父节点>
        while (len(queue) > 0):
            vertex = queue.pop()
            nodes = graph[vertex]
            for w in nodes:
                if w not in seen:
                    parent[w] = vertex
                    queue.append(w)
                    seen.add(w)
            print(vertex)
        return parent
    
    if __name__ == "__main__":
        print (DFS(graph,"A"))
    
    
    ```

+ 使用BFS求最短路径(Dijkstra)：

  + ![1571536767397](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1571536767397.png)

  + ```python
    import heapq # 权限比队列
    import math
    graph = {
        "A": {"B": 5, "C": 1},
        "B": {"A": 5, "C": 2},
        "C": {"A": 1, "B": 2, "D": 4},
        "D": {"B": 1, "C": 4, "E": 3, "F": 6},
        "E": {"C": 8, "D": 3},
        "F": {"D": 6}
    }
    
    
    def init_distance(graph, s):
        distance = {s: 0}
        for vertex in graph.keys():
            if vertex != s:
                distance[vertex] = math.inf
        return distance
    
    
    def dijkstra(graph, s):
        pqueue = []  # prorityqueue 具有权重比的队列，权重高的排前面
        heapq.heappush(pqueue, (0, s))
        seen = set()
        parent = {s: None}
        distance = init_distance(graph, s)
    
        while(len(pqueue) > 0):
            pair = heapq.heappop(pqueue)
            dist = pair[0]  # 取出来的点到s的距离
            vertex = pair[1]
            seen.add(vertex)
    
            nodes = graph[vertex].keys()
            for w in nodes:
                if w not in seen:
                    if dist+graph[vertex][w] < distance[w]: 
                        distance[w] = dist+graph[vertex][w]
                        heapq.heappush(pqueue, (dist+graph[vertex][w], w))
                        parent[w] = vertex
        return parent, distance
    
    
    parent, distance = dijkstra(graph, "A")
    print(parent)
    print(distance)
    
    ```

  + 