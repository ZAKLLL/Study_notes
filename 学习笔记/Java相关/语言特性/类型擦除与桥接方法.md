#  桥接方法(Bridge Methods)

+ 为了保证类型擦除后保留通用类型的多态性，Java编译器会生成桥接方法，以确保子类型化能按预期进行。

+ [Effects of Type Erasure and Bridge Methods (The Java™ Tutorials > Learning the Java Language > Generics (Updated)) (oracle.com)](https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html)

## EG

+ 有下面一段代码，父类带泛型.

  ```java
  public class Node<T> {
  
      public T data;
  
      public Node(T data) { this.data = data; }
  
      public void setData(T data) {
          System.out.println("Node.setData");
          this.data = data;
      }
  }
  
  public class MyNode extends Node<Integer> {
      public MyNode(Integer data) { super(data); }
  
      public void setData(Integer data) {
          System.out.println("MyNode.setData");
          super.setData(data);
      }
  }
  ```

  当执行如下代码时

  ```java
  //正常代码
  MyNode mn = new MyNode(5);
  Node n = mn;            // A raw type - compiler throws an unchecked warning
  n.setData("Hello");     // Causes a ClassCastException to be thrown.
  Integer x = mn.data;   
  
  //运行时类型擦除之后
  MyNode mn = new MyNode(5);
  Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning
  n.setData("Hello");          // Causes a ClassCastException to be thrown.
  Integer x = (String)mn.data; 
  ```

+ 运行时进行泛型擦除之后,代码可能如下所示.

  + ```java
    public class Node {
    
        public Object data;
    
        public Node(Object data) { this.data = data; }
    
        public void setData(Object data) {
            System.out.println("Node.setData");
            this.data = data;
        }
    }
    
    public class MyNode extends Node {
    
        public MyNode(Integer data) { super(data); }
    
        public void setData(Integer data) {
            System.out.println("MyNode.setData");
            super.setData(data);
        }
    }
    ```

  + 在类型清除后，方法签名不匹配；Node.setData(T)方法变成Node.setData(Object)。因此，MyNode.setData(Integer)方法并没有覆盖Node.setData(Object)方法。为了解决这个问题，并在类型清除后保留通用类型的多态性，Java编译器生成了一个桥接方法，以确保子类型化如期进行。

  + 对于MyNode类，编译器为setData生成了以下桥接方法：

    ```java
    class MyNode extends Node {
    
        // Bridge method generated by the compiler
        //
        public void setData(Object data) {
            setData((Integer) data);
        }
    
        public void setData(Integer data) {
            System.out.println("MyNode.setData");
            super.setData(data);
        }
    
        // ...
    }
    ```

  + **桥接方法MyNode.setData(object)委托给了原来的MyNode.setData(Integer)方法。结果，n.setData("Hello");语句调用了MyNode.setData(Object)方法，并且抛出了一个ClassCastException，因为 "Hello "不能被转换为Integer。**

