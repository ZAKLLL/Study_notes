![1567329656435](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1567329656435.png)

![1567330450870](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1567330450870.png)

![1567330598718](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1567330598718.png)

+ 设计范式：

  + 1 、第一范式（1NF）

    指数据库表的每一列(即每个属性)都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。简而言之，第一范式就是无重复的列。

    2、 第二范式（2NF）

    第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。

    第二范式（2NF）要求实体的属性完全依赖于主关键字。

    所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。

    简而言之，第二范式就是非主属性依赖于主关键字。

    3 、第三范式（3NF）

    在满足第二范式的基础上，切不存在传递函数依赖，那么就是第三范式。

    简而言之，第三范式就是属性不依赖于其它非主属性。

+ Join关键字;
  + ![1567335994073](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1567335994073.png)

+ Mysql联合索引最左匹配原则:

  + ```sql
    CREATE TABLE `user` (
      `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键Id',
      `name` varchar(255) DEFAULT NULL COMMENT '名称',
      `age` int(11) DEFAULT NULL COMMENT '年龄',
      `address` varchar(255) DEFAULT NULL COMMENT '地址',
      `created_time` datetime DEFAULT NULL COMMENT '创建时间',
      `updated_time` datetime DEFAULT NULL COMMENT '更新时间',
      PRIMARY KEY (`id`),
      KEY `idx_com1` (`name`,`age`,`address`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表';
    ```

  + ```sql
    该查询语句没有使用到索引idx_com1
    select  *  from user where age = 25 and address='北京大兴区';
    原因：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候
    b+数是按照从左到右的顺序来建立搜索树的，
    比如当(张三,20,F)这样的数据来检索的时候，
    b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；
    但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点
    ```

+ truncate和delete的相同点与不同点：

  + **相同点**：
    + 效果上，delete from tableA，与truncate table tableA的作用是一样的（如果delete后面不添加where条件过滤），而且与drop table tableA，接着create table tableA的效果也是一样的。

  + **不同点** ：

    + **1、语言上**

      delete是DML，truncate是DDL，执行truncate需要drop权限。

      **2、效率上**

      delete是一行一行的删除，所以执行速度不快。由于truncate是DDL，是通过删除表然后重建表实现的，执行速度很快。

      **3、事务上**

      delete过程如果出现错误，事务是可以回滚的，而truncate无法回滚。

      **4、效果上**

      - delete可以删除符合条件的数据行，而truncate只能删除整体
      - delete可以返回被删除的记录数，而truncate只返回0，没有任何意义
      - 在存储引擎为InnoDB的数据库服务器中，如果一个表的主键作为了另一个表的外键，那么truncate无法删除这个表中的数据，无论这个外键是否存在，这是由于drop表限制的。而delete可以，只要这个表的主键在另一个表的外键中不存在即可。
      - truncate删除一个表的数据后，这个表的auto_increment列重新设置为初始大小，而delete则使用删除之前的顺序。索引同理。