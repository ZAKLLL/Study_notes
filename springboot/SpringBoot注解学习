## 注解源码

+ @Configuration注解

  + 指示一个类声明了一个或多个@Bean方法，并且可以由Spring容器进行处理以在运行时为这些bean生成bean定义和服务请求，例如：
    

    ```java
       @Configuration
       public class AppConfig {  
    	   @Bean
    	   public MyBean myBean() {
        	   // instantiate, configure and return bean ...
    	   }
       }
    ```
    引导@Configuration类
    通过AnnotationConfigApplicationContext
    通常使用AnnotationConfigApplicationContext或其支持Web的变体AnnotationConfigWebApplicationContext来引导@Configuration类。 前者的一个简单示例如下：

       ```java
       AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
       ctx.register(AppConfig.class);
       ctx.refresh();
       MyBean myBean = ctx.getBean(MyBean.class);
       // use myBean ...
       ```

    

+ 使用@import导入配置类：

  + With the @Import annotation
    @Configuration类可以使用@Import注释组成，类似于<import>在Spring XML中的工作方式。 因为@Configuration对象作为容器中的Spring bean管理，所以可以注入导入的配置-例如，通过构造函数注入：

    ```java
           @Configuration
           public class DatabaseConfig {
               @Bean
               public DataSource dataSource() {
                   // instantiate, configure and return DataSource
               }
           }
    
           @Configuration
           @Import(DatabaseConfig.class)
           public class AppConfig {
    
               private final DatabaseConfig dataConfig;
              
               //自动注入构造函数参数
               public AppConfig(DatabaseConfig dataConfig) {
                   this.dataConfig = dataConfig;
               }
              
               @Bean
               public MyBean myBean() {
                   // reference the dataSource() bean method
                   return new MyBean(dataConfig.dataSource());
               }
           }
    ```
    
    
    
    现在，可以通过仅在Spring上下文中注册AppConfig来引导AppConfig和导入的DatabaseConfig：
    
    ```java
    new AnnotationConfigApplicationContext(AppConfig.class);
    ```
    
  + 使用@Profile指定开发配置：

    带有@Profile批注
    @Configuration类可以用@Profile注释标记，以指示仅当给定的一个或多个配置文件处于活动状态时才应处理它们：

    ```java
       @Profile("development")
       @Configuration
       public class EmbeddedDatabaseConfig {
    
           @Bean
           public DataSource dataSource() {
               // instantiate, configure and return embedded DataSource
           }
    
       }
    
       @Profile("production")
       @Configuration
       public class ProductionDatabaseConfig {
           @Bean
           public DataSource dataSource() {
               // instantiate, configure and return production DataSource
           }
    
       }
    ```

    另外，您也可以在@Bean方法级别声明配置文件条件-例如，对于同一配置类中的替代bean变体：

       ```java
       @Configuration
       public class ProfileDatabaseConfig {
    
           @Bean("dataSource")
           @Profile("development")
           public DataSource embeddedDatabase() { ... }
          
           @Bean("dataSource")
           @Profile("production")
           public DataSource productionDatabase() { ... }
    
       }
       ```

  + 嵌套配置类

    + @Configuration classes may be nested within one another as follows:

      ```java
         @Configuration
         public class AppConfig {
      
             @Inject DataSource dataSource;
            
             @Bean
             public MyBean myBean() {
                 return new MyBean(dataSource);
             }
            
             @Configuration
             static class DatabaseConfig {
                 @Bean
                 DataSource dataSource() {
                     return new EmbeddedDatabaseBuilder().build();
                 }
             }
      
         }
      ```

      在引导这种安排时，仅需要针对应用程序上下文注册AppConfig。 由于是嵌套的@Configuration类，因此将自动注册DatabaseConfig。 当AppConfig和DatabaseConfig之间的关系已经隐式清除时，这避免了使用@Import批注的需要。
      还要注意，嵌套的@Configuration类可以与@Profile批注一起使用，为封闭的@Configuration类提供同一bean的两个选项。